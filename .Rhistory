df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","orange")) +
labs(x = "Preços", y = "Fitted Values") +
theme_bw()
set.seed(123)
rf_simples <- randomForest(
formula = precos ~ .,
data    = treino
)
rf_simples
plot(rf_simples)
# número de árvores com o menor MSE (mean squared error)
which.min(rf_simples$mse)
# RMSE (root mean squared error) do random forest com menor MSE
sqrt(rf_simples$mse[which.min(rf_simples$mse)])
# nome das variaveis de entrada (p)
features <- setdiff(names(treino), "precos")
length(features)
# passo opcional: tentar encontrar o valor de mtry otimo para a árvore
set.seed(1234)
modelo_2 <- tuneRF(
x          = treino[features],
y          = treino$precos,
ntreeTry   = 500,
mtryStart  = 5,
stepFactor = 1.5,
improve    = 0.01,
trace      = FALSE      # não mostar o progresso em tempo real
)
# comparar com o valor padrão do pacote (p/3)
length(features)/3
# Escolhendo pacote para o processo iterativo
# Tempo decorrido no randomForest
system.time(
tempo_randomForest <- randomForest(
formula = precos ~ .,
data    = df_bairros_dummies,
ntree   = 500,
mtry    = floor(length(features) / 3)
)
)
# Tempo decorrido no ranger speed
system.time(
tempo__ranger <- ranger(
formula   = precos ~ .,
data      = df_bairros_dummies,
num.trees = 500,
mtry      = floor(length(features) / 3)
)
)
# Criando dataframe com todas as possíveis combinações dos parãmetros
hyper_grid <- expand.grid(
mtry       = seq(2, 7, by = 1),
sampe_size = seq(.5, .9, by = 0.02),
node_size  = seq(2, 5, by = 1),
OOB_RMSE   = 0
)
# número de combinações obtidos
nrow(hyper_grid)
system.time(
for(i in 1:nrow(hyper_grid)) {
model <- ranger(
formula         = precos ~ .,
data            = treino,
num.trees       = 500,
mtry            = hyper_grid$mtry[i],
min.node.size   = hyper_grid$node_size[i],
sample.fraction = hyper_grid$sampe_size[i],
seed            = 123
)
# Adicionando OOB no dataframe das combinações possíveis
#treino$temp <- predict(model, treino)$predictions
#hyper_grid$RMSE[i] <- accuracy(treino$precos,treino$temp)[2]
hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}
)
hyper_grid %>%
dplyr::arrange(OOB_RMSE) %>%
head(5)
tuning_values <- hyper_grid[which.min(hyper_grid$OOB_RMSE),]
tuning_values
#OOB RMSE vária entre 216.6448 e 2450.9158
min(hyper_grid$OOB_RMSE)
max(hyper_grid$OOB_RMSE)
OOB_RMSE <- vector(mode = "numeric", length = 100)
set.seed(1234)
for(i in seq_along(OOB_RMSE)) {
optimal_ranger <- ranger(
formula         = precos ~ .,
data            = treino,
num.trees       = 500,
mtry            = tuning_values$mtry,
min.node.size   = tuning_values$node_size,
sample.fraction = tuning_values$sampe_size,
importance      = 'impurity'
)
OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}
hist(OOB_RMSE, breaks = 20)
optimal_ranger$variable.importance %>%
tidy() %>%
dplyr::arrange(desc(x)) %>%
dplyr::top_n(25) %>%
ggplot(aes(reorder(names, x), x)) +
xlab("Variável") +
ylab("Importância da Variável") +
geom_col() +
coord_flip() +
ggtitle("")
set.seed(1234)
optimal_rf <- randomForest(
formula = precos ~ .,
data    = treino,
num.trees = 500,
mtry = tuning_values$mtry,
min.node.size = tuning_values$node_size,
sample.fraction = tuning_values$sampe_size
)
min(optimal_rf$mse)
sqrt(min(optimal_rf$mse))
min(rf_simples$mse)
sqrt(min(rf_simples$mse))
df_resultados$rf_simples_fitted <- predict(rf_simples, teste)
df_resultados$ranger_fitted <- predict(optimal_ranger, teste)$predictions
df_resultados$rf_fitted <- predict(optimal_rf, teste)
#Plotando
df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_simples_fitted, color = "4 - RF Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_fitted, color = "5 - RF Otimizado"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","blue")) +
labs(x = "Preços", y = "Valores Preditos") +
theme_bw()
accuracy(df_resultados$precos,df_resultados$fitted_step)
accuracy(df_resultados$precos,df_resultados$fitted_step_bc)
accuracy(df_resultados$precos,df_resultados$rf_simples_fitted)
accuracy(df_resultados$precos,df_resultados$rf_fitted)
accuracy(df_resultados$precos,df_resultados$ranger_fitted)
#############################################################################################################
#Estudo sobre o desbalanceamento dos dados
aggregate(data.frame(contagem = df_bairros$bairro), list(bairro = df_bairros$bairro), length)
#Preco medio da acomodação por
aggregate(data.frame(media = df_bairros$precos), list(bairro = df_bairros$bairro), FUN=mean)
#Exploração visual do preco médio
df_bairros %>%
group_by(bairro) %>%
mutate(preco_medio = mean(precos, na.rm = TRUE)) %>%
ggplot() +
geom_point(aes(x = bairro, y = precos),color = "orange", alpha = 0.5, size = 2) +
geom_line(aes(x = bairro, y = preco_medio,
group = 1, color = "Preço Médio por Bairro"), size = 1.5) +
scale_colour_viridis_d() +
labs(x = "Bairro",
y = "Preço") +
theme(legend.title = element_blank(),
panel.border = element_rect(NA),
panel.grid = element_line("grey"),
panel.background = element_rect("white"),
legend.position = "bottom",
axis.text.x = element_text(angle = 90))
#Kernel density estimation (KDE) - função densidade de probabilidade da
#variável dependente (precos) por bairro
ggplotly(
ggplot(df_bairros, aes(x = precos)) +
geom_density(aes(color = bairro, fill = bairro),
position = "identity", alpha = 0.3) +
scale_color_viridis_d() +
scale_fill_viridis_d() +
theme_classic()
)
#Preco medio da acomodação por
aggregate(data.frame(media = df_bairros$precos), list(bairro = df_bairros$bairro), FUN=mean)
#Exploração visual do preco médio
df_bairros %>%
group_by(bairro) %>%
mutate(preco_medio = mean(precos, na.rm = TRUE)) %>%
ggplot() +
geom_point(aes(x = bairro, y = precos),color = "orange", alpha = 0.5, size = 2) +
geom_line(aes(x = bairro, y = preco_medio,
group = 1, color = "Preço Médio por Bairro"), size = 1.5) +
scale_colour_viridis_d() +
labs(x = "Bairro",
y = "Preço") +
theme(legend.title = element_blank(),
panel.border = element_rect(NA),
panel.grid = element_line("grey"),
panel.background = element_rect("white"),
legend.position = "bottom",
axis.text.x = element_text(angle = 90))
accuracy(df_resultados$precos,df_resultados$tree_fitted)
#####################################
pacotes <- c(
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'viridis',    # Escalas 'viridis' para o ggplot2
'caret',       # Funções úteis para machine learning
'AMR',
'randomForest',
'fastDummies',
'rattle',
'xgboost',
'rsample',
'ranger',
'caret',
'forecast',
'h2o'
)
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
accuracy(df_resultados$precos,df_resultados$tree_fitted)
#Kernel density estimation (KDE) - função densidade de probabilidade da
#variável dependente (precos) por bairro
ggplotly(
ggplot(df_bairros, aes(x = precos)) +
geom_density(aes(color = bairro, fill = bairro),
position = "identity", alpha = 0.3) +
scale_color_viridis_d() +
scale_fill_viridis_d() +
theme_classic()
)
#Kernel density estimation (KDE) - função densidade de probabilidade da
#variável dependente (precos) por bairro
ggplotly(
ggplot(df_bairros, aes(x = precos)) +
geom_density(aes(color = bairro, fill = bairro),
position = "identity", alpha = 0.3) +
scale_color_viridis_d() +
scale_fill_viridis_d() +
theme_classic()
)
#####################################
pacotes <- c(
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'viridis',    # Escalas 'viridis' para o ggplot2
'caret',       # Funções úteis para machine learning
'AMR',
'randomForest',
'fastDummies',
'rattle',
'xgboost',
'rsample',
'ranger',
'caret',
'forecast',
'h2o'
)
df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","orange")) +
labs(x = "Preços", y = "Fitted Values") +
theme_bw()
#####################################
pacotes <- c(
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'viridis',    # Escalas 'viridis' para o ggplot2
'caret',       # Funções úteis para machine learning
'AMR',
'randomForest',
'fastDummies',
'rattle',
'xgboost',
'rsample',
'ranger',
'caret',
'forecast',
'h2o'
)
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Construindo a árvore simples
system.time(
tree <- rpart(precos ~ . - precos,
data=treino,
control=rpart.control(maxdepth = 30, cp=0))
)
# Valores preditos para uma arvore simples
df_resultados$tree_fitted = predict(tree, teste)
df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","orange")) +
labs(x = "Preços", y = "Fitted Values") +
theme_bw()
#Plotando
df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_simples_fitted, color = "4 - RF Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_fitted, color = "5 - RF Otimizado"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","blue")) +
labs(x = "Preços", y = "Valores Preditos") +
theme_bw()
accuracy(df_resultados$precos,df_resultados$tree_fitted)
accuracy(df_resultados$precos,df_resultados$fitted_step)
accuracy(df_resultados$precos,df_resultados$fitted_step_bc)
accuracy(df_resultados$precos,df_resultados$rf_simples_fitted)
accuracy(df_resultados$precos,df_resultados$rf_fitted)
accuracy(df_resultados$precos,df_resultados$ranger_fitted)
#############################################################################################################
#Estudo sobre o desbalanceamento dos dados
aggregate(data.frame(contagem = df_bairros$bairro), list(bairro = df_bairros$bairro), length)
#Preco medio da acomodação por
aggregate(data.frame(media = df_bairros$precos), list(bairro = df_bairros$bairro), FUN=mean)
#Exploração visual do preco médio
df_bairros %>%
group_by(bairro) %>%
mutate(preco_medio = mean(precos, na.rm = TRUE)) %>%
ggplot() +
geom_point(aes(x = bairro, y = precos),color = "orange", alpha = 0.5, size = 2) +
geom_line(aes(x = bairro, y = preco_medio,
group = 1, color = "Preço Médio por Bairro"), size = 1.5) +
scale_colour_viridis_d() +
labs(x = "Bairro",
y = "Preço") +
theme(legend.title = element_blank(),
panel.border = element_rect(NA),
panel.grid = element_line("grey"),
panel.background = element_rect("white"),
legend.position = "bottom",
axis.text.x = element_text(angle = 90))
#Kernel density estimation (KDE) - função densidade de probabilidade da
#variável dependente (precos) por bairro
ggplotly(
ggplot(df_bairros, aes(x = precos)) +
geom_density(aes(color = bairro, fill = bairro),
position = "identity", alpha = 0.3) +
scale_color_viridis_d() +
scale_fill_viridis_d() +
theme_classic()
)
hist(OOB_RMSE, breaks = 20)
optimal_ranger$variable.importance %>%
tidy() %>%
dplyr::arrange(desc(x)) %>%
dplyr::top_n(25) %>%
ggplot(aes(reorder(names, x), x)) +
xlab("Variável") +
ylab("Importância da Variável") +
geom_col() +
coord_flip() +
ggtitle("")
set.seed(1234)
optimal_rf <- randomForest(
formula = precos ~ .,
data    = treino,
num.trees = 500,
mtry = tuning_values$mtry,
min.node.size = tuning_values$node_size,
sample.fraction = tuning_values$sampe_size
)
min(optimal_rf$mse)
sqrt(min(optimal_rf$mse))
min(rf_simples$mse)
sqrt(min(rf_simples$mse))
df_resultados$rf_simples_fitted <- predict(rf_simples, teste)
df_resultados$ranger_fitted <- predict(optimal_ranger, teste)$predictions
df_resultados$rf_fitted <- predict(optimal_rf, teste)
#Plotando
df_resultados %>%
ggplot() +
geom_smooth(aes(x = precos, y = fitted_step_bc, color = "2 - Box-Cox - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= fitted_step, color = "1 - Linear - Stepwise"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= tree_fitted, color = "3 - Árvore Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_simples_fitted, color = "4 - RF Simples"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y= rf_fitted, color = "5 - RF Otimizado"),
method = "lm", se = F, formula = y ~ splines::bs(x, df = 5),
size = 1.5) +
geom_smooth(aes(x = precos, y = precos), method = "lm",
color = "gray44", size = 1.05,
linetype = "longdash") +
scale_color_manual("Modelos:",
values = c("deepskyblue1","darkorchid","springgreen3","chocolate1","red","blue")) +
labs(x = "Preços", y = "Valores Preditos") +
theme_bw()
#############################################################################################################
#Estudo sobre o desbalanceamento dos dados
aggregate(data.frame(contagem = df_bairros$bairro), list(bairro = df_bairros$bairro), length)
optimal_ranger$variable.importance %>%
tidy() %>%
dplyr::arrange(desc(x)) %>%
dplyr::top_n(25) %>%
ggplot(aes(reorder(names, x), x)) +
xlab("Variável") +
ylab("Importância da Variável") +
geom_col() +
coord_flip() +
ggtitle("")
#Exploração visual do preco médio
df_bairros %>%
group_by(bairro) %>%
mutate(preco_medio = mean(precos, na.rm = TRUE)) %>%
ggplot() +
geom_point(aes(x = bairro, y = precos),color = "orange", alpha = 0.5, size = 2) +
geom_line(aes(x = bairro, y = preco_medio,
group = 1, color = "Preço Médio por Bairro"), size = 1.5) +
scale_colour_viridis_d() +
labs(x = "Bairro",
y = "Preço") +
theme(legend.title = element_blank(),
panel.border = element_rect(NA),
panel.grid = element_line("grey"),
panel.background = element_rect("white"),
legend.position = "bottom",
axis.text.x = element_text(angle = 90))
